name: Supply Chain Integrity

on:
  push:
    branches: [ main, trunk, master ]
    tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ main, trunk, master ]
  workflow_dispatch: {}

permissions:
  contents: read
  packages: write      # for GHCR push
  id-token: write      # for keyless cosign

jobs:
  sbom-and-attest:
    name: Generate SBOMs & Attest Image
    runs-on: ubuntu-latest
    env:
      IMAGE: ghcr.io/${{ github.repository }}:${{ github.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@d70bba72b1f3fd22344832f00baa16ece964efeb # v3.4.0

      - name: Login to GHCR (skip on forks)
        if: github.event.pull_request.head.repo.fork == false
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          syft version

      - name: Build application image
        run: |
            docker build -t "$IMAGE" -f Dockerfile .
            if [ "${{ github.event.pull_request.head.repo.fork }}" = "false" ]; then
              docker push "$IMAGE"
            else
              echo "Skipping push on fork.";
            fi

      - name: Build secure prometheus-nats-exporter image (sanity)
        if: exists('build/prometheus-nats-exporter/Dockerfile.secure')
        run: |
          docker build -f build/prometheus-nats-exporter/Dockerfile.secure -t exporter-secure:latest .

      - name: Build syncdaemon image
        run: |
          if [ -f services/syncdaemon/Dockerfile ]; then
            docker build -t "$IMAGE-syncdaemon" -f services/syncdaemon/Dockerfile .
            if [ "${{ github.event.pull_request.head.repo.fork }}" = "false" ]; then
              docker push "$IMAGE-syncdaemon" || true
            fi
          else
            echo "syncdaemon Dockerfile not found; skipping"
          fi

      - name: Generate SOURCE SBOM (SPDX JSON)
        run: syft dir:. -o spdx-json=sbom-source.spdx.json

      - name: Generate IMAGE SBOM (SPDX JSON)
        run: syft oci:"$IMAGE" -o spdx-json=sbom-image.spdx.json || syft docker:"$IMAGE" -o spdx-json=sbom-image.spdx.json

      - name: Upload SBOM Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sboms-${{ github.sha }}
          path: |
            sbom-source.spdx.json
            sbom-image.spdx.json
          if-no-files-found: error

      - name: Install Cosign
        uses: sigstore/cosign-installer@9614fae9e5c5eddabb09f90a270fcb487c9f7149 # v3.5.0

      - name: Cosign attest image SBOM (keyless)
        # Non-fatal on forks or permission issues
        continue-on-error: true
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" = "true" ]; then
            echo "Fork detected: skipping attestation push."; exit 0; fi
          if ! docker manifest inspect "$IMAGE" >/dev/null 2>&1; then
            echo "Image not in registry (likely fork w/o push) - skip attestation"; exit 0; fi
          echo "Attesting SBOM for $IMAGE";
          cosign attest --predicate sbom-image.spdx.json --type spdx "$IMAGE" || echo "Cosign attest failed (non-fatal)"

      - name: Cosign attest syncdaemon image SBOM (keyless)
        continue-on-error: true
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" = "true" ]; then
            echo "Fork detected: skipping syncdaemon attestation push."; exit 0; fi
          if ! docker manifest inspect "$IMAGE-syncdaemon" >/dev/null 2>&1; then
            echo "Syncdaemon image not in registry - skip attestation"; exit 0; fi
          cosign attest --predicate sbom-image.spdx.json --type spdx "$IMAGE-syncdaemon" || echo "Cosign attest failed (non-fatal)"

      - name: Cosign sign image (optional, non-fatal)
        if: github.event.pull_request.head.repo.fork == false
        continue-on-error: true
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          cosign sign --yes "$IMAGE" || echo "Cosign sign failed (non-fatal)"

      - name: Upload Edge Sync Evidence Bundle
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: edge_sync_manifest
          path: |
            services/syncdaemon/logs/*.jsonl
          if-no-files-found: ignore

      - name: Trivy FS scan (repo)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: 'fs'
          format: 'sarif'
          output: 'trivy-fs.sarif'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload FS scan SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-fs.sarif

      - name: Trivy Image scan (app image)
        if: github.event.pull_request.head.repo.fork == false
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.IMAGE }}
          format: 'sarif'
          output: 'trivy-image.sarif'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload Image scan SARIF to GitHub Security
        if: github.event.pull_request.head.repo.fork == false
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-image.sarif

      - name: Summarize
        run: |
          echo "SBOMs generated:"; ls -1 sbom-*.spdx.json || true
          echo "Workflow complete."
